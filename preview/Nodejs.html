<html>
  <head>
	  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>i5ting_ztree_toc:Nodejs</title>
		<link href="toc/style/github-bf51422f4bb36427d391e4b75a1daa083c2d840e.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/style/github2-d731afd4f624c99a4b19ad69f3083cd6d02b81d5.css" media="all" rel="stylesheet" type="text/css"/>
		<link href="toc/css/zTreeStyle/zTreeStyle.css" media="all" rel="stylesheet" type="text/css"/>
	  <style>
		pre {
		    counter-reset: line-numbering;
		    border: solid 1px #d9d9d9;
		    border-radius: 0;
		    background: #fff;
		    padding: 0;
		    line-height: 23px;
		    margin-bottom: 30px;
		    white-space: pre;
		    overflow-x: auto;
		    word-break: inherit;
		    word-wrap: inherit;
		}

		pre a::before {
		  content: counter(line-numbering);
		  counter-increment: line-numbering;
		  padding-right: 1em; /* space after numbers */
		  width: 25px;
		  text-align: right;
		  opacity: 0.7;
		  display: inline-block;
		  color: #aaa;
		  background: #eee;
		  margin-right: 16px;
		  padding: 2px 10px;
		  font-size: 13px;
		  -webkit-touch-callout: none;
		  -webkit-user-select: none;
		  -khtml-user-select: none;
		  -moz-user-select: none;
		  -ms-user-select: none;
		  user-select: none;
		}

		pre a:first-of-type::before {
		  padding-top: 10px;
		}

		pre a:last-of-type::before {
		  padding-bottom: 10px;
		}

		pre a:only-of-type::before {
		  padding: 10px;
		}

		.highlight { background-color: #ffffcc } /* RIGHT */
		</style>
  </head>
  <body>
	  <div>
				<div style='width:25%;'>
						<ul id="tree" class="ztree" style='width:100%'>

						</ul>
				</div>
        <div id='readme' style='width:70%;margin-left:20%;'>
          	<article class='markdown-body'>
            	<hr>
<p>title: Nodejs学习记录01
date: 2022-1-20 16:20:33
tags:</p>
<ul>
<li>Nodejs</li>
<li>JavaScript</li>
<li>前端
categories:</li>
<li>前端学习</li>
<li>Nodejs</li>
</ul>
<hr>
<h2 id="node-js-">Node.js学习记录</h2>
<h3 id="-javascript-">浏览器中的JavaScript的组成部分</h3>
<ol>
<li>JS核心语法</li>
<li>变量、数据类型</li>
<li>循环、分支、判断</li>
<li>函数、作用域、this</li>
<li>etc(面向对象等)</li>
<li>WebAPI</li>
<li>DOM操作</li>
<li>BOM操作</li>
<li>基于XMLHttpRequest的Ajax操作</li>
<li>etc</li>
</ol>
<h3 id="-javascript-">为什么JavaScript可以在浏览器中被执行</h3>
<p><img src="./img/浏览器为何可以执行js代码.png" alt="节点">
不同的浏览器使用不同的JavaScript解析引擎：</p>
<ul>
<li>Chrome浏览器 =&gt; V8</li>
<li>Firefox浏览器 =&gt; OdinMonkey  --奥丁猴</li>
<li>Safri浏览器 =&gt; JSCore</li>
<li>IE浏览器 =&gt; Chakra  --查克拉</li>
<li>etc</li>
</ul>
<p>其中，Chrome 浏览器的V8解析引擎最好！</p>
<h3 id="-javascript-dom-bom">为什么JavaScript可以操纵DOM和BOM</h3>
<p><img src="./img/js为何可以操纵dom和bom.png" alt="节点"></p>
<h3 id="-javascript-">浏览器中的JavaScript运行环境</h3>
<p><img src="./img/浏览器中的js运行环境.png" alt="节点"></p>
<p>总结：</p>
<ol>
<li>V8引擎负责解析和执行JavaScript代码</li>
<li>内置API是由<span style="color: red">运行环境</span>提供的特殊接口，<span style="color: rgb(234, 28, 32)">只能在所属的运行环境中被调用</span></li>
</ol>
<h3 id="-node-js">什么是Node.js</h3>
<pre><code>Node.js是一个基于Chorome V8引擎的JavaScript运行环境
</code></pre><h3 id="node-js-js-">Node.js的js运行环境</h3>
<p><img src="./img/Node.js中的JavaScript运行环境.png" alt="节点"></p>
<p>注意：</p>
<ol>
<li>浏览器是JavaScript的前端运行环境。</li>
<li>Node.js是JavaScript的后端运行环境。</li>
<li>Node.js中级工无法调用DOM和BOM等浏览器内置API</li>
</ol>
<h3 id="node-js-">Node.js可以做什么</h3>
<ol>
<li>基于EXpress框架(<a href="http://www.expressjs.com.cn/)">http://www.expressjs.com.cn/)</a>, 可以快速构建Web应用</li>
<li>基于Electron框架(<a href="https://electronjs.org/)">https://electronjs.org/)</a>, 可以构建跨平台的桌面应用</li>
<li>基于restify框架(<a href="http://restify.com/)">http://restify.com/)</a>, 可以快速构建API接口项目</li>
<li>读写和操作数据库、创建使用的命令行工具辅助前端开发、etc...</li>
</ol>
<h3 id="fs-">fs文件系统模块</h3>
<h4 id="-fs-">什么是fs文件系统模块</h4>
<p><span style="color: red">fs模块</span>是Node.js官方提供的、用来操作文件的模块。它提供了一系列的方法和属性，用来满足用户对文件的操作需求。</p>
<p>eg：</p>
<ol>
<li>fs.readFile()方法，用来读取指定文件中的内容</li>
<li>fs.writeFile()方法，用来向指定的文件中写入内容</li>
</ol>
<p>如果要在JavaScript代码中，使用fs模块来操作文件，则需要使用如下的方式先导入它：</p>
<pre><code class="lang-js">const fs = require(&#39;fs&#39;)
</code></pre>
<h4 id="-">读取指定文件中的内容</h4>
<ol>
<li>fs.readFile()的语法格式
使用fs.readFile()方法，可以读取指定文件中的内容，语法格式如下：<pre><code class="lang-js">fs.readFile(path[, options], callback)
</code></pre>
参数解读：</li>
<li>必选参数(path), 字符串, 表示文件的路径。</li>
<li>可选参数(options), 表示以什么编码格式来读取文件。</li>
<li><p>必选参数(callback), 文件读取完成后, 通过回调函数拿到读取的结果。</p>
</li>
<li><p>fs.readFile()的示例代码
<code>`</code>js
const fs = require(&#39;fs&#39;)</p>
</li>
</ol>
<p>fs.readFile(path, &#39;utf8&#39;, function(err, dataStr){
    if(err) return console.log(&#39;读取文件失败&#39;, err.message)</p>
<pre><code>console.log(&#39;读取成功&#39;, dataStr)
</code></pre><p>})</p>
<pre><code>
#### 向指定的文件中写入内容

##### fs.writeFile()的格式

使用fs.writeFile()方法，可以向指定的文件中写入内容，语法格式如下：

```js
fs.writeFile(file, data[, options], callback)
</code></pre><p>参数解读：</p>
<ul>
<li>必选参数(file), 需要指定一个文件路径的字符串，表示文件的存放路径。</li>
<li>必选参数(data), 表示要写入的内容,</li>
<li>可选参数(options), 表示以什么编码格式来读取文件。</li>
<li>必选参数(callback), 文件写入完成后的回调函数</li>
</ul>
<p>注意点：</p>
<ol>
<li>fs.writeFile()方法只能用来创建文件，不能用来创建路径</li>
<li>重复调用fs.writeFile() 写入同一个文件，新写入的内容会覆盖之前的旧内容</li>
</ol>
<h4 id="fs-">fs路径动态拼接的问题</h4>
<p>在使用fs模块操作文件时，如果提供的操作路径是以./或../开头的<span style="color: red">相对路径</span>时，很容易出现路径动态拼接错误的问题。</p>
<ol>
<li><p>原因：代码在运行时，<span style="color: red">会以执行node命令时所处的目录<span/>，动态拼接出被操作文件的完整路径。</p>
</li>
<li><p>解决方案：</p>
</li>
</ol>
<p><b>方案1：提供一个完整的文件存放路径(绝对路径)</b></p>
<p>缺点：移植性非常差、不利于维护</p>
<p><b>方案2：__dirname + &#39;相对文件路径&#39;</b></p>
<h3 id="path-">path路径模块</h3>
<h4 id="-">概念</h4>
<p>path模块时Node.js官方提供的、用来处理路径的模块。它提供了一系列的方法和属性吗，用来满足用户对路径的处理需求。</p>
<p>eg:</p>
<ol>
<li>path.join()方法，用来将多个路径片段拼接成一个完整的路径字符串</li>
<li>path.basename()方法，用来从路径字符串中，将文件名解析出来</li>
</ol>
<p>同理要先导入</p>
<pre><code class="lang-js">const path = require(&#39;path&#39;)
</code></pre>
<h4 id="-">路径拼接</h4>
<ol>
<li>path,join的语法格式</li>
</ol>
<p>使用path.join()方法，可以把多个路径拼接成完整的路径字符串，语法格式如下：</p>
<pre><code class="lang-js">path.join([...paths])
</code></pre>
<p>参数解读：</p>
<p>· ...paths: 字符串 路径片段的序列
· 返回值：字符串</p>
<p>eg:</p>
<pre><code class="lang-js">const pathStr = path.join(&#39;/a&#39;, &#39;/b/c&#39;, &#39;../&#39;. &#39;./d&#39;, &#39;e&#39;)
console.log(pathStr)  // 输出  \a\b\d\e

const pathStr2 = path.join(__dirname, &#39;./files/1.txt)
console.log(pathStr2)
</code></pre>
<p>注意：<span style="color: red">今后凡是涉及到路径拼接的操作，都要使用path.join()方法处理</span>。不要直接使用+进行字符串的拼接 
原因：eg： fs.readFile(path.join(__dirname + &#39;./files/1.txt&#39;)) 可以屏蔽掉. 然后+不行。</p>
<h4 id="-">获取路径中的文件名</h4>
<ol>
<li>path.basename()的语法格式</li>
</ol>
<p>使用path.basename()方法，可以从一个文件路径中，获取到文件的名称部分：</p>
<pre><code class="lang-js">const fpath = &#39;/a&#39;
</code></pre>
<h4 id="-">获取路径中的文件扩展名</h4>
<ol>
<li>path.extname()的语法格式</li>
</ol>
<p>使用path.extname()方法，可以获取路径中的扩展名部分：</p>
<pre><code class="lang-js">const fpath = &#39;/a/b/c/index.html/&#39; 

const fext = path.extname(fpath)

console.log(fext)  //  输出 .html
</code></pre>
<h3 id="http-">http模块</h3>
<h4 id="-">什么是客户端、什么是服务器</h4>
<p>在网络节点中，负责消费资源的电脑，叫做客户端；负责对外提供网络资源的电脑，叫做服务器。</p>
<p><span style="color: red">http模块</span>是Node.js官方提供的、用来<span style="color: red">创建Web服务器</span>的模块。通过http模块提供的<span style="color: skyblue">http.createServer()方法</span>，就能方便的把一台普通的电脑，变成一台Web服务器，从而对外提供Web资源服务。</p>
<p>如果要希望使用http模块创建Web服务器，则需要先导入它：</p>
<pre><code class="lang-js">const http = require(&#39;http&#39;)
</code></pre>
<h4 id="-http-">进一步理解http模块的作用</h4>
<p>服务器和普通电脑的<span style="color: red">区别</span>在于，服务器上安装了Web服务器软件，例如：IIS、Apache等。通过安装这些服务器软件，就能把一台普通的电脑变成一台Web服务器。</p>
<p>在Node.js中，我们<span style="color: skyblue">不需要使用</span>IIS、Apache等这些第三方Web服务器软件。因为我们可以基于Node.js提供的http模块，<span style="color: red">通过几行简单的代码，就能轻松的手写一个服务器软件</span>，从而对外提供Web服务。</p>
<h4 id="-">服务器相关的概念</h4>
<ol>
<li>IP地址</li>
</ol>
<p><span style="color: red">IP地址</span>就是互联网上<span style="color: red">每一台计算机的唯一地址</span>，因此IP地址具有唯一性。如果把&quot;个人电脑&quot;比作&quot;一台电话&quot;，那么&quot;IP地址&quot;就相当于&quot;电话号码&quot;，只有在知道对方的IP地址的前提下，才能与对应的电脑之间进行数据通信。</p>
<p>IP地址的格式：通常用&quot;点分十进制&quot;表示成(a,b,c,d)的形式，其中，a-d都是0-255之间的十进制整数。例如：用点分十进表示的IP地址(192.168.1.1)</p>
<p>注意：</p>
<ol>
<li>互联网中每台Web服务器，都有自己的IP地址，例如：可以在Win终端中运行 ping <a href="http://www.baidu.com命令，即可查到百度服务器的IP地址。">www.baidu.com命令，即可查到百度服务器的IP地址。</a></li>
<li><p>在开发期间，自己的电脑既是一台服务器，也是一个客户端，为了方便测试，可以在自己的浏览器中输入127.0.0.1这个IP地址，就能把自己的电脑当作服务器来访问了。</p>
</li>
<li><p>域名和域名服务器</p>
</li>
</ol>
<p>域名就是字符型的地址方案，即所谓的域名地址(Domain Name)</p>
<p>IP地址和域名是一一对应的关系，这份对应关系存放在一种叫做服务器(DNS, Domain name server)的电脑中。使用者只需通过好记的域名访问对应的服务器即可，对应的转换工作由域名服务器实现。因此，域名服务器就是提供IP地址和域名之间的转换服务的服务器。</p>
<p>注意：</p>
<ol>
<li>单纯使用IP地址，互联网中的电脑也能正常工作。有域名，能让它更方便。</li>
<li><p>在开发测试期间，127.0.0.1对应的域名是localhost，他们都代表我们自己的电脑，在使用效果上没有任何区别。</p>
</li>
<li><p>端口号</p>
</li>
</ol>
<p>一台电脑中，可以运行成百上千个Web服务。每个Web服务器都对应一个唯一的端口号。客户端发送过来的网络请求，通过端口号，可以被准确地交给对应的Web服务进行处理。
<img src="img/端口号.png" alt="">
注意：</p>
<ol>
<li>每个端口号不能同时被多个Web服务占用。</li>
<li>在实际应用中，URL中的80端口可以被省略</li>
</ol>
<h4 id="-web-">创建基本的web服务器</h4>
<p>Step:</p>
<ol>
<li>导入http模块<pre><code class="lang-js">const http = require(&#39;http&#39;)
</code></pre>
</li>
<li>调用http.createServer()方法</li>
</ol>
<pre><code class="lang-js">const server = http.createServer()
</code></pre>
<ol start="3">
<li><p>为服务器实例绑定request事件，即可监听客户端发送过来的网络请求：</p>
<pre><code class="lang-js">server.on(&#39;request&#39;, (req,res) =&gt; {
// 只要有客户端来请求我们自己的服务器，就会触发request事件，从而调用这个事件处理函数
console.log(&#39;Someone visit our web server&#39;)
})
</code></pre>
</li>
<li><p>启动服务器</p>
</li>
</ol>
<p>调用服务器实例的.listen()方法，即可启动当前的Web服务器实例：</p>
<pre><code class="lang-js">// 调用 server.listen(端口号，cb回调)方法，即可启动Web服务器
server.listen(80, ()=&gt;{
   console.log(&#39;http server running at http://127.0.0.1&#39;)
})
</code></pre>
<ol start="5">
<li>req请求对象</li>
</ol>
<p>只要服务器接收到了客户端的请求，就会调用通过server.on()为服务器绑定的request事件处理函数。如果想在事件处理函数中，访问与客户端相关的数据或属性，可以使用如下的方式：</p>
<pre><code class="lang-js">server.on(&#39;request&#39;,(req)=&gt;{
    //req 是请求对象
    const str = &#39;Your request url is ${req.url} , and request method is ${req.method}&#39;
    console.log(str)
})
</code></pre>
<ol start="6">
<li>res响应对象</li>
</ol>
<p>在服务器的request事件处理函数中，如果想访问与服务器相关的数据或者属性，可以使用如下方式：</p>
<pre><code class="lang-js">server.on(&#39;request&#39;, (req,res)=&gt;{
    // res是响应对象，它包含了与服务器相关的数据和属性，例如：
    // 要发送到客户端的字符串
    const str = `Your request url is ${req.url},and request method is ${req.method}`
    // req.end()方法的作用：
    // 向客户端发送指定的内容，并结束这次请求的处理过程
    res.end(str)
})
</code></pre>
<ol start="7">
<li>解决中文乱码的问题</li>
</ol>
<p>当调用res.end()方法，向客户端发送中文内容的时候，会出现乱码问题，此时，需要手动设置内容的编码格式：</p>
<pre><code class="lang-js">server.on(&#39;request&#39;,(req, res)=&gt;{
    const str = `您请求的url地址是 ${req.url}, 请求的method是${req.method}`

    // 调用res.setHeader()方法，设置Content-Type响应头，解决中文乱码的问题
    res.setHeader(&#39;Content-Type&#39;, &#39;text/html; charset=utf-8&#39;)

    res.end(str)
})
</code></pre>
<h4 id="-url-html-">根据不同的url响应不同的html内容</h4>
<ol>
<li><p>核心实现步骤：</p>
<p>获取请求的url地址
设置默认的响应内容为404 Not found
判断用户请求的是否为 / 或 /index.html首页
判断用户请求的是否为 /about.html 关于页面
设置Content-Type响应头，防止中午乱码
使用res.end()把内容响应给客户端</p>
</li>
<li><p>动态响应内容：</p>
</li>
</ol>
<pre><code class="lang-js">server.on(&#39;request&#39;, function(req, res) {
    const url = req.url

    let content = &#39;&lt;h1&gt; 404 Not found&lt;/h1&gt;&#39;

    if(url === &#39;/&#39; || url === &#39;/index.html&#39;) {
        content = &#39;&lt;h1&gt;首页&lt;/h1&gt;&#39;

    }else if(url === &#39;/about.html&#39;){
        content = &#39;&lt;h1&gt;关于页面&lt;/h1&gt;&#39;
    }
    res.setHeader(&#39;Content-Type&#39;, &#39;text/html; charset=utf-8&#39;)
    res.end(content)
})
</code></pre>
<h3 id="-">模块化的基本概念</h3>
<h4 id="-">什么是模块化</h4>
<pre><code>模块化是指解决一个复杂问题时，自顶向下逐层把系统划分成若干模块的过程。对于整个系统来说，模块是可组合、分解和更换的单元。
</code></pre><p>编程领域中的模块化，就是遵守固定的规则，摆一个大文件拆成独立并互相依赖的多个小模块。</p>
<p>把代码进行模块化拆分的好处：</p>
<ol>
<li>提高了代码的复用性</li>
<li>提高了代码的可维护性</li>
<li>可以实现按需加载</li>
</ol>
<h4 id="-">模块化规范</h4>
<p>模块化规范就是对代码进行模块化的拆分与组合时，需要遵守的那些规则。</p>
<p>例如：</p>
<ul>
<li>使用什么样的语法格式来引用模块</li>
<li>在模块中使用什么样的语法格式向外暴露成员</li>
</ul>
<p>模块化规范的好处：大家都遵守同样的模块化规范写代码，降低了沟通的成本，极大方便了各个模块之间的相互调用，利人利己。</p>
<h3 id="node-js-">Node.js中的模块化</h3>
<h4 id="node-js-">Node.js中模块的分类</h4>
<p>Node.js中根据模块来源的不同，将模块分为了3大类，分别是：</p>
<ul>
<li>内置模块(内置模块是由Node.js官方提供的，例如fs、path、http等)</li>
<li>自定义模块(用户创建的每个.js文件，都是自定义模块)</li>
<li>第三方模块(由第三方开发出来的模块，并非官方提供的内置模块，也不是用户创建的自定义模块，使用前需要先下载 )</li>
</ul>
<h4 id="-">加载模块</h4>
<p>使用强大的require()方法，可以加在需要的内置模块、用户自定义模块、第三方模块进行使用。例如：</p>
<pre><code class="lang-js">// 加载内置fs模块
const fs = require(&#39;fs&#39;)

// 加载用户自定义模块
const custom = require(&#39;./custom.js&#39;)

// 加载第三方模块(关于第三方模块的下载和使用，会在后面的课程中进行专门的讲解)
const moment = require(&#39;moment&#39;)
</code></pre>
<p>注意：使用require()方法加载其他模块时，会执行被加载模块中的代码</p>
<h4 id="node-js-">Node.js中的模块作用域</h4>
<ol>
<li>什么是模块作用域</li>
</ol>
<p>和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域。</p>
<ol start="2">
<li>模块作用域的好处</li>
</ol>
<p>防止了全局变量污染的问题</p>
<p><img src="./img2/global variable pollution.png" alt=""></p>
<h4 id="-">向外共享模块作用域中的成员</h4>
<ol>
<li>module对象</li>
</ol>
<p>在每个.js自定义模块中都有一个module对象，它里面存储了和当前模块有关的信息，打印如下：
<img src="./img2/module.png" alt=""></p>
<ol start="2">
<li>module.exports对象</li>
</ol>
<p>在自定义模块中，可以使用module.exports对象，将模块内的成员共享出去，供外界使用。
外界用require()方法导入自定义模块时，得到的即使module.exports所指的对象</p>
<ol start="3">
<li>共享成员时的注意点</li>
</ol>
<p>使用require()方法导入模块时，导入的结果，永远以module.exports指向的对象为准。</p>
<ol start="4">
<li>exports对象</li>
</ol>
<p>默认情况下，exports和module.exports指向同一个对象。最终共享的结果，还是以module.exports结果为准。</p>
<h4 id="node-js-">Node.js中的模块化规范</h4>
<pre><code>Node.js遵循了CommonJS模块化规范，CommonJS规定了模块的特性和各模块之间如何相互依赖。
</code></pre><p>CommonJS规定：</p>
<ol>
<li>每个模块内部，module变量代表当前模块。</li>
<li>module变量是一个对象，它的exports属性(即module.exports)是对外接口。</li>
<li>加载某个模块，其实是加载该模块的module.exports属性。require()方法用于加载模块</li>
</ol>
<h3 id="npm-">npm与包</h3>
<h4 id="-">什么是包</h4>
<p>NOde.js中的第三方模块又叫做包</p>
<p>第三方模块和包是一个概念，只是叫法不同。</p>
<h4 id="-">为什么需要包</h4>
<p>由于Node.js的内置模块仅提供一些底层的API，导致在基于内置模块进行项目开发时，效率很低。</p>
<p>包是基于内置模块封装出来的，提供了更高级、更方便的API，极大的提高了开发效率。</p>
<p>包和内置模块之间的关系，类似于jQuery和浏览器内置API之间的关系。</p>
<h4 id="npm-">npm初体验</h4>
<ol>
<li>格式化时间的传统做法</li>
</ol>
<p>step:</p>
<ul>
<li>创建格式化时间的自定义模块</li>
<li>定义格式化时间的方法</li>
<li>创建补零函数</li>
<li>从自定义模块中导出格式化时间的函数</li>
<li>导入时间格式化的自定义模块</li>
<li>调用格式化时间的函数</li>
</ul>
<pre><code class="lang-js">function dataFormat(dtStr){
    const dt = new Date()

    const y = dt.getFullYear()
    const m = padZero(dt.getMonth() + 1) 
    const d = padZero(dt.getDate()) 

    const hh = padZero(dt.getHours()) 
    const mm = padZero(dt.getMinutes()) 
    const ss = padZero(dt.getSeconds()) 

    return `${y}-${m}-${d} ${hh}:${mm}:${ss} `
};

// 补零函数
function padZero(n){
    return n &gt; 9 ? n : &#39;0&#39; + n
}

module.exports = {
    dataFormat
}
</code></pre>
<ol start="2">
<li><p>格式化时间的高级做法</p>
</li>
<li><p>使用npm包管理工具，在项目中安装格式化时间的包moment</p>
</li>
<li>使用require()导入格式化时间的包</li>
<li>参考moment官方API文档对时间进行格式化
<code>`</code>js
const moment = require(&#39;moment&#39;)</li>
</ol>
<p>const dt = moment().format(&#39;YYYY-MM-DD HH:mm:ss&#39;)</p>
<p>console.log(dt)</p>
<pre><code>
3. 包的语义化版本规范

包的版本号是以&quot;点分十进制&quot;形式进行定义的，总共有三位数字，例如2.24.0

其中每一位数字所代表的含义如下：
第1位数字：大版本
第2位数字：功能版本
第3位数字：Bug修复版本

版本号提升的规则：只要前面的版本号增长了，则后面的版本号归零。

#### 包管理配置文件

    npm规定，在项目根目录中，必须提供一个叫做package.json的包管理配置文件。用来记录与项目有关的一些配置信息。例如：
    * 项目的名称、版本号、描述等
    * 项目中都用到了哪些包
    * 哪些包只会在开发期间会用到
    * 那些包在开发和部署时都需要用到

1. 快速创建package.json

npm包管理工具提供了一个快捷命令，可以在执行命令时所处的目录中，快速创建package.json这个包管理配置文件：
```js
npm init -y 
</code></pre><p>注意：</p>
<ul>
<li>上述命令只能在英文的目录下成功运行！所以，项目文件夹的名称一定要使用英文命名，不要使用中文，不能出现空格。</li>
<li><p>运行npm install 命令安装包的时候，npm 包管理工具会自动的把包名称和版本号  ，记录到package.json中。</p>
</li>
<li><p>dependencies节点</p>
</li>
</ul>
<p>package.json文件中，有一个dependencies节点，专门用来记录您使用npm install 命令安装了哪些包</p>
<p><img src="./img3/packagejson.png" alt=""></p>
<ol start="3">
<li>卸载包</li>
</ol>
<p>可以运行npm uninstall命令，来卸载指定的包</p>
<pre><code class="lang-js">npm uninstall moment
</code></pre>
<p>注意：npm uninstall 命令执行成功后，会把卸载的包，自动地从package.json的dependencies中移除掉。</p>
<ol start="4">
<li><p>devDependencies节点</p>
<p> 如果某些包只在项目开发阶段会用到，在项目上线之后不会用到，则建议把这些包记录到devDependencies节点中。
 与之对应的，如果某些包在开发阶段和项目上线之后都需要用到，则建议把这些包记录到dependencies节点中。</p>
</li>
</ol>
<p>您可以使用如下的命令，将包记录到devDependencies节点中：</p>
<pre><code class="lang-js">npm i 包名 -D

npm install 包名 --save--dev
</code></pre>
<h4 id="-">解决下包速度慢的问题</h4>
<ol>
<li>淘宝npm镜像服务器</li>
</ol>
<p>慢的原因如图：
<img src="img3/olddownload.png" alt=""></p>
<p>淘宝在国内搭建了一个服务器，专门把国外服务器上的包同步到国内的服务器，然后在国内提供下包的服务。从而极大的提供了下包的速度。
<img src="img3/newdownload.png" alt=""></p>
<p>扩展：
镜像(Mirroring)是一种文件存储形式，一个磁盘上的数据在另一个磁盘上存在一个完全相同的副本即为镜像。</p>
<ol start="2">
<li>切换npm的下包镜像源</li>
</ol>
<p>下包的镜像源，指的就是下包的服务器地址。</p>
<pre><code class="lang-js">// 查看当前的下包镜像源
npm config get registry
// 将下包的镜像源切换为淘宝镜像源
npm config set registry = https://registry.npm.taobao.org/
// 检查镜像源是否下载成功
npm config get registry
</code></pre>
<ol start="3">
<li>nrm</li>
</ol>
<p>为了更方便的切换下包的镜像源，我们可以安装nrm这个小工具，利用nrm提供的终端命令，可以快速查看和切换下包的镜像源</p>
<pre><code class="lang-js">// 通过npm包管理器，将nrm安装为全局可用的工具
npm i nrm -g
// 查看所有可用的镜像源
nrm ls
// 将下包的镜像源切换为taobao镜像
nrm use taobao
</code></pre>
<h4 id="-">包的分类</h4>
<ol>
<li>项目包</li>
</ol>
<p>那些被安装到项目的node_modules 目录中的包，都是项目包。</p>
<p>项目包又分为两类，分别是：</p>
<ul>
<li>开发依赖包(被记录到devDependencies节点中的包，只会在开发期间会用到)</li>
<li>核心依赖包(被记录到dependencies节点中的，在开发期间和项目上线之后都会用到)</li>
</ul>
<pre><code class="lang-js">npm i 包名 -D
npm i 包名
</code></pre>
<ol start="2">
<li>全局包</li>
</ol>
<p>在执行npm install命令时，如果提供了-g参数，则会把包安装为全局包。
全局包会被安装到C:\Users\用户目录\AppData\Roaming\npm\node_modules目录下。</p>
<pre><code class="lang-js">npm i 包名-g
npm uninstall 包名 -g 
</code></pre>
<p>注意：</p>
<ul>
<li>只有工具性质的包，才有全局安装的必要性。因为它们提供了好用的终端命令。</li>
<li><p>判断某个包是否需要全局安装后才能使用，可以参考官方提供的使用说明即可。</p>
</li>
<li><p>i5ting_toc</p>
</li>
</ul>
<p>i5ting_toc是一个可以把md文档转为html 页面的小工具，使用步骤如下：</p>
<pre><code class="lang-js">npm i -g i5ting_toc

// 调用i5ting_toc ，轻松实现md转为html的功能
i5ting_toc -f 要转换的md文件路径 -o
</code></pre>

          	</article>
        </div>
		</div>
  </body>
</html>
<script type="text/javascript" src="toc/js/jquery-1.4.4.min.js"></script>
<script type="text/javascript" src="toc/js/jquery.ztree.all-3.5.min.js"></script>
<script type="text/javascript" src="toc/js/ztree_toc.js"></script>
<script type="text/javascript" src="toc_conf.js"></script>

<SCRIPT type="text/javascript" >
<!--
$(document).ready(function(){
    var css_conf = eval(markdown_panel_style);
    $('#readme').css(css_conf)
    
    var conf = eval(jquery_ztree_toc_opts);
		$('#tree').ztree_toc(conf);
});
//-->
</SCRIPT>